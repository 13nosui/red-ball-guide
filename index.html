<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Ball Guide - 3D Puzzle</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #fff;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        button:active {
            transform: scale(0.95);
        }
        #playBtn {
            border-color: #ff3333;
            color: #ff3333;
        }
        #playBtn.playing {
            border-color: #33ff33;
            color: #33ff33;
        }
        #status {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="status">GOAL THE BALL!</div>
    <div id="ui">
        <button id="moveLeft">←</button>
        <button id="moveRight">→</button>
        <button id="rotate">ROTATE</button>
        <button id="playBtn">PLAY</button>
    </div>

    <!-- CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        /**
         * RED BALL GUIDE - Prototype
         */

        // --- 設定 ---
        const GRID_SIZE = 2;
        const STAGE_WIDTH = 20;
        const STAGE_HEIGHT = 12;

        let scene, camera, renderer, world;
        let ball, ballBody, ballStartPos = { x: -8, y: 5 };
        let slope, slopeBody, slopePos = { x: 0, y: -2 }, slopeRotation = 0;
        let walls = [], goals = [];
        let isPlaying = false;
        let goalBody;

        // --- 初期化 ---
        function init() {
            // Three.js Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            const aspect = window.innerWidth / window.innerHeight;
            const d = 10;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(0, 0, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            // Cannon.js Setup
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            createStage();
            createBall();
            createSlope();
            setupEventListeners();

            animate();
        }

        // --- ステージ作成 ---
        function createStage() {
            // 床
            createWall(0, -5.5, 20, 1);
            // 左壁
            createWall(-10.5, 0, 1, 12);
            // 右壁
            createWall(10.5, 0, 1, 12);
            
            // ゴール領域表示 (黄色いワイヤーフレーム)
            const goalGeo = new THREE.BoxGeometry(3, 1, 2);
            const goalEdges = new THREE.EdgesGeometry(goalGeo);
            const goalMat = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const goalLine = new THREE.LineSegments(goalEdges, goalMat);
            goalLine.position.set(7, -4.5, 0);
            scene.add(goalLine);

            // ゴール判定用センサー (物理挙動なし、位置のみ使用)
            goalBody = {
                minX: 5.5, maxX: 8.5,
                minY: -5, maxY: -4
            };
        }

        function createWall(x, y, w, h) {
            const geo = new THREE.BoxGeometry(w, h, 2);
            const edges = new THREE.EdgesGeometry(geo);
            const mat = new THREE.LineBasicMaterial({ color: 0xffffff });
            const wireframe = new THREE.LineSegments(edges, mat);
            wireframe.position.set(x, y, 0);
            scene.add(wireframe);

            const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, 1));
            const body = new CANNON.Body({ mass: 0 });
            body.addShape(shape);
            body.position.set(x, y, 0);
            world.addBody(body);
            walls.push({ mesh: wireframe, body: body });
        }

        // --- ボール作成 ---
        function createBall() {
            // Visual
            const geo = new THREE.SphereGeometry(0.5, 32, 32);
            const mat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            ball = new THREE.Mesh(geo, mat);
            ball.position.set(ballStartPos.x, ballStartPos.y, 0);
            scene.add(ball);

            // Physics
            const shape = new CANNON.Sphere(0.5);
            ballBody = new CANNON.Body({
                mass: 1,
                shape: shape,
                position: new CANNON.Vec3(ballStartPos.x, ballStartPos.y, 0)
            });
            ballBody.type = CANNON.Body.KINEMATIC; // 最初は静止
            world.addBody(ballBody);
        }

        // --- スロープ作成 (直角三角形) ---
        function createSlope() {
            // Visual
            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.lineTo(2, 0);
            shape.lineTo(0, 2);
            shape.lineTo(0, 0);

            const extrudeSettings = { depth: 2, bevelEnabled: false };
            const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const edges = new THREE.EdgesGeometry(geo);
            const mat = new THREE.LineBasicMaterial({ color: 0xffffff });
            slope = new THREE.LineSegments(edges, mat);
            
            // 中央にピボットを合わせるための調整
            geo.translate(-0.5, -0.5, -1); 
            slope.position.set(slopePos.x, slopePos.y, 0);
            scene.add(slope);

            // Physics (ConvexPolyhedron for triangle)
            // 簡略化のため、3つの平面を組み合わせるか、ConvexPolyhedronを使用
            const vertices = [
                new CANNON.Vec3(0, 0, -1),
                new CANNON.Vec3(2, 0, -1),
                new CANNON.Vec3(0, 2, -1),
                new CANNON.Vec3(0, 0, 1),
                new CANNON.Vec3(2, 0, 1),
                new CANNON.Vec3(0, 2, 1)
            ];
            const faces = [
                [0, 1, 2], [3, 5, 4], // Bottom, Top
                [0, 3, 4, 1], [1, 4, 5, 2], [2, 5, 3, 0] // Sides
            ];
            const slopeShape = new CANNON.ConvexPolyhedron(vertices, faces);
            slopeBody = new CANNON.Body({ mass: 0 });
            slopeBody.addShape(slopeShape, new CANNON.Vec3(-0.5, -0.5, 0));
            slopeBody.position.set(slopePos.x, slopePos.y, 0);
            world.addBody(slopeBody);
        }

        // --- UIイベント ---
        function setupEventListeners() {
            document.getElementById('moveLeft').onclick = () => {
                if(isPlaying) return;
                slopePos.x -= GRID_SIZE;
                updateSlopeTransform();
            };
            document.getElementById('moveRight').onclick = () => {
                if(isPlaying) return;
                slopePos.x += GRID_SIZE;
                updateSlopeTransform();
            };
            document.getElementById('rotate').onclick = () => {
                if(isPlaying) return;
                slopeRotation += Math.PI / 2;
                updateSlopeTransform();
            };
            document.getElementById('playBtn').onclick = () => {
                const btn = document.getElementById('playBtn');
                if(!isPlaying) {
                    isPlaying = true;
                    btn.innerText = 'RESET';
                    btn.classList.add('playing');
                    ballBody.type = CANNON.Body.DYNAMIC;
                    document.getElementById('status').innerText = "WATCHING...";
                } else {
                    resetGame();
                }
            };

            window.addEventListener('resize', () => {
                const aspect = window.innerWidth / window.innerHeight;
                const d = 10;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function updateSlopeTransform() {
            slope.position.set(slopePos.x, slopePos.y, 0);
            slope.rotation.z = slopeRotation;
            slopeBody.position.set(slopePos.x, slopePos.y, 0);
            slopeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), slopeRotation);
        }

        function resetGame() {
            isPlaying = false;
            const btn = document.getElementById('playBtn');
            btn.innerText = 'PLAY';
            btn.classList.remove('playing');
            document.getElementById('status').innerText = "GOAL THE BALL!";

            // ボールリセット
            ballBody.type = CANNON.Body.KINEMATIC;
            ballBody.position.set(ballStartPos.x, ballStartPos.y, 0);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
            ballBody.quaternion.set(0, 0, 0, 1);
            
            ball.position.copy(ballBody.position);
            ball.quaternion.copy(ballBody.quaternion);
        }

        // --- アニメーションループ ---
        function animate() {
            requestAnimationFrame(animate);

            if(isPlaying) {
                world.step(1/60);
                
                // Sync Visuals
                ball.position.copy(ballBody.position);
                ball.quaternion.copy(ballBody.quaternion);

                // Check Goal
                if(ball.position.x > goalBody.minX && ball.position.x < goalBody.maxX &&
                   ball.position.y > goalBody.minY && ball.position.y < goalBody.maxY) {
                    document.getElementById('status').innerText = "SUCCESS! GOAL!!";
                    document.getElementById('status').style.color = "#ffff00";
                }

                // Check Fall Out
                if(ball.position.y < -10) {
                    document.getElementById('status').innerText = "FAILED... TRY AGAIN";
                    document.getElementById('status').style.color = "#ff3333";
                }
            }

            renderer.render(scene, camera);
        }

        // 実行開始
        init();

    </script>
</body>
</html>
