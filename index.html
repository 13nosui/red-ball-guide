<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Red Ball Guide - Mobile Optimized</title>
    <style>
        :root {
            --ui-bg: rgba(0, 0, 0, 0.85);
            --wire-color: rgba(255, 255, 255, 0.8);
            --accent-red: #FF3333;
            --accent-green: #33FF33;
            --accent-yellow: #FFFF33;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            /* 防止スワイプ揺れ */
            -webkit-user-select: none;
            user-select: none;
        }

        #container {
            width: 100%;
            height: 75%;
            /* 画面上部75%をゲームに */
            position: absolute;
            top: 0;
            left: 0;
        }

        #control-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25%;
            /* 画面下部25% */
            background: var(--ui-bg);
            border-top: 1px solid var(--wire-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            box-sizing: border-box;
            z-index: 100;
        }

        .action-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .dpad {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 5px;
        }

        /* 今回は左右移動のみだが将来的に上下も対応可能なD-Pad構成 */
        #btnLeft {
            grid-area: left;
        }

        #btnRight {
            grid-area: right;
        }

        button {
            min-width: 60px;
            min-height: 50px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--wire-color);
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.1s, transform 0.05s;
            touch-action: manipulation;
            outline: none;
        }

        button:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
        }

        .primary-btn {
            padding: 10px 20px;
            font-size: 18px;
            letter-spacing: 2px;
        }

        #playBtn {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }

        #playBtn.playing {
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        #status {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: var(--wire-color);
            font-size: 20px;
            letter-spacing: 3px;
            pointer-events: none;
            z-index: 10;
        }

        /* D-Pad 矢印ワイヤーデザイン */
        .arrow-icon {
            width: 0;
            height: 0;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
        }

        .arrow-left {
            border-right: 15px solid #fff;
        }

        .arrow-right {
            border-left: 15px solid #fff;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div id="status">INITIATING GUIDE...</div>

    <div id="control-panel">
        <div class="action-group">
            <button id="rotateBtn" class="primary-btn">ROTATE</button>
            <button id="playBtn" class="primary-btn">PLAY</button>
        </div>

        <div class="dpad">
            <button id="btnLeft">
                <div class="arrow-icon arrow-left"></div>
            </button>
            <button id="btnRight">
                <div class="arrow-icon arrow-right"></div>
            </button>
        </div>
    </div>

    <!-- CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        /**
         * RED BALL GUIDE - Mobile Optimized Prototype
         */

        const GRID_SIZE = 2;
        let scene, camera, renderer, world;
        let ball, ballBody, ballStartPos = { x: -8, y: 5 };
        let slope, slopeBody, slopePos = { x: 0, y: -2 }, slopeRotation = 0;
        let isPlaying = false;
        let goalRegion = { minX: 5.5, maxX: 8.5, minY: -5.5, maxY: -4 };

        function init() {
            // Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            const container = document.getElementById('container');
            const w = container.clientWidth;
            const h = container.clientHeight;
            const aspect = w / h;
            const d = 10;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(0, 0, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(w, h);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(5, 10, 7.5);
            scene.add(sun);

            // Physics
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();

            setupStage();
            setupBall();
            setupSlope();
            setupControls();

            animate();

            document.getElementById('status').innerText = "CALIBRATE SLOPE";
        }

        function createWireBox(w, h, x, y, color = 0xFFFFFF) {
            const geo = new THREE.BoxGeometry(w, h, 2);
            const edges = new THREE.EdgesGeometry(geo);
            const mat = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const line = new THREE.LineSegments(edges, mat);
            line.position.set(x, y, 0);
            scene.add(line);

            const body = new CANNON.Body({ mass: 0 });
            body.addShape(new CANNON.Box(new CANNON.Vec3(w / 2, h / 2, 1)));
            body.position.set(x, y, 0);
            world.addBody(body);
            return { mesh: line, body: body };
        }

        function setupStage() {
            //Floor
            createWireBox(20, 1, 0, -5.5);
            //Walls
            createWireBox(1, 12, -10.5, 0);
            createWireBox(1, 12, 10.5, 0);

            // Goal (Yellow)
            const goalGeo = new THREE.BoxGeometry(3, 1, 2);
            const goalEdges = new THREE.EdgesGeometry(goalGeo);
            const goalMat = new THREE.LineBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.8 });
            const goalLine = new THREE.LineSegments(goalEdges, goalMat);
            goalLine.position.set(7, -4.5, 0);
            scene.add(goalLine);
        }

        function setupBall() {
            // Visual: Matte Red Ball
            const geo = new THREE.SphereGeometry(0.5, 32, 32);
            const mat = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                roughness: 0.8,
                metalness: 0.2
            });
            ball = new THREE.Mesh(geo, mat);
            ball.position.set(ballStartPos.x, ballStartPos.y, 0);
            scene.add(ball);

            // Physics
            ballBody = new CANNON.Body({
                mass: 1,
                shape: new CANNON.Sphere(0.5),
                position: new CANNON.Vec3(ballStartPos.x, ballStartPos.y, 0)
            });
            ballBody.type = CANNON.Body.KINEMATIC;
            world.addBody(ballBody);
        }

        function setupSlope() {
            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.lineTo(2, 0);
            shape.lineTo(0, 2);
            shape.lineTo(0, 0);

            const geo = new THREE.ExtrudeGeometry(shape, { depth: 2, bevelEnabled: false });
            geo.translate(-1, -1, -1); // Center the pivot

            const edges = new THREE.EdgesGeometry(geo);
            const mat = new THREE.LineBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 });
            slope = new THREE.LineSegments(edges, mat);
            slope.position.set(slopePos.x, slopePos.y, 0);
            scene.add(slope);

            // Physics Triangle
            const v = [
                new CANNON.Vec3(-1, -1, -1), new CANNON.Vec3(1, -1, -1), new CANNON.Vec3(-1, 1, -1),
                new CANNON.Vec3(-1, -1, 1), new CANNON.Vec3(1, -1, 1), new CANNON.Vec3(-1, 1, 1)
            ];
            const f = [[0, 1, 2], [3, 5, 4], [0, 3, 4, 1], [1, 4, 5, 2], [2, 5, 3, 0]];
            slopeBody = new CANNON.Body({ mass: 0 });
            slopeBody.addShape(new CANNON.ConvexPolyhedron(v, f));
            slopeBody.position.set(slopePos.x, slopePos.y, 0);
            world.addBody(slopeBody);
        }

        function handleMove(dir) {
            if (isPlaying) return;
            slopePos.x += dir * GRID_SIZE;
            updateSlope();
        }

        function handleRotate() {
            if (isPlaying) return;
            slopeRotation += Math.PI / 2;
            updateSlope();
        }

        function updateSlope() {
            slope.position.set(slopePos.x, slopePos.y, 0);
            slope.rotation.z = slopeRotation;
            slopeBody.position.set(slopePos.x, slopePos.y, 0);
            slopeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), slopeRotation);
        }

        function togglePlay() {
            const btn = document.getElementById('playBtn');
            if (!isPlaying) {
                isPlaying = true;
                btn.innerText = "RESET";
                btn.classList.add('playing');
                ballBody.type = CANNON.Body.DYNAMIC;
                document.getElementById('status').innerText = "LIVE SIMULATION";
            } else {
                reset();
            }
        }

        function reset() {
            isPlaying = false;
            const btn = document.getElementById('playBtn');
            btn.innerText = "PLAY";
            btn.classList.remove('playing');
            document.getElementById('status').innerText = "CALIBRATE SLOPE";
            document.getElementById('status').style.color = "var(--wire-color)";

            // Complete physical reset
            ballBody.type = CANNON.Body.KINEMATIC;
            ballBody.position.set(ballStartPos.x, ballStartPos.y, 0);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
            ballBody.quaternion.set(0, 0, 0, 1);

            ball.position.copy(ballBody.position);
            ball.quaternion.copy(ballBody.quaternion);
        }

        function setupControls() {
            const bind = (id, fn) => {
                const el = document.getElementById(id);
                // touchstart で即応性確保
                el.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    fn();
                }, { passive: false });
                // マウス操作用
                el.addEventListener('click', (e) => {
                    e.preventDefault();
                    //すでtouchstartで処理されている場合は二重実行を防ぐロジックが必要だが、
                    //PCブラウザ互換性のために単純に定義
                });
            };

            bind('btnLeft', () => handleMove(-1));
            bind('btnRight', () => handleMove(1));
            bind('rotateBtn', handleRotate);
            bind('playBtn', togglePlay);

            window.addEventListener('resize', () => {
                const container = document.getElementById('container');
                const w = container.clientWidth;
                const h = container.clientHeight;
                const aspect = w / h;
                const d = 10;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isPlaying) {
                world.step(1 / 60);
                ball.position.copy(ballBody.position);
                ball.quaternion.copy(ballBody.quaternion);

                // Goal Check
                if (ball.position.x > goalRegion.minX && ball.position.x < goalRegion.maxX &&
                    ball.position.y > goalRegion.minY && ball.position.y < goalRegion.maxY) {
                    document.getElementById('status').innerText = "TARGET REACHED";
                    document.getElementById('status').style.color = "var(--accent-yellow)";
                }

                // Fail Check
                if (ball.position.y < -10) {
                    document.getElementById('status').innerText = "OUT OF BOUNDS";
                    document.getElementById('status').style.color = "var(--accent-red)";
                }
            }
            renderer.render(scene, camera);
        }

        window.onload = init;
        // スクロール等のデフォルト動作をグローバルに禁止
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

    </script>
</body>

</html>