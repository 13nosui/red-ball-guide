-- src/Server/GameManager.server.luau
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Shared = ReplicatedStorage:WaitForChild("Shared")
local Events = Shared:WaitForChild("Events")
local Palette = require(Shared:WaitForChild("Palette"))

local GameControlEvent = require(Events.GameControlEvent)

-- è¨­å®š
-- ã‚´ãƒ¼ãƒ«è‡ªä½“ã®åšã¿ã¯ç¢ºä¿ã—ã¤ã¤ã€ã‚¹ãƒ­ãƒ¼ãƒ—ã§ç™»ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
local GOAL_POSITION = Vector3.new(0, 3, -20)
local START_POSITION = Vector3.new(0, 15, 0)
local BALL_SIZE = 4
local HOLE_SIZE = 5.5
local GOAL_HEIGHT = 6
local GOAL_WIDTH = 12

-- çŠ¶æ…‹
local currentBall = nil
local isGoalLocked = false

-- â–  ã‚´ãƒ¼ãƒ«ç”Ÿæˆé–¢æ•°
local function spawnGoal()
	local existingGoal = workspace:FindFirstChild("GoalModel")
	if existingGoal then
		existingGoal:Destroy()
	end

	local model = Instance.new("Model")
	model.Name = "GoalModel"

	-- 1. åœŸå°ï¼ˆãƒ™ãƒ¼ã‚¹ï¼‰
	local basePart = Instance.new("Part")
	basePart.Name = "Base"
	basePart.Size = Vector3.new(GOAL_WIDTH, GOAL_HEIGHT, GOAL_WIDTH)
	basePart.CFrame = CFrame.new(GOAL_POSITION)
	basePart.Color = Palette.Entity.GoalBase
	basePart.Material = Enum.Material.Grass
	basePart.Anchored = true

	-- 2. ç©´ã‚ã‘ç”¨ãƒ‘ãƒ¼ãƒ„
	local holeCutter = Instance.new("Part")
	holeCutter.Name = "Cutter"
	holeCutter.Shape = Enum.PartType.Cylinder
	holeCutter.CFrame = basePart.CFrame * CFrame.Angles(0, 0, math.rad(90))
	-- ç¢ºå®Ÿã«è²«é€šã•ã›ã‚‹ãŸã‚é•·ã•ã‚’å°‘ã—ä½™åˆ†ã«ã¨ã‚‹ (10)
	holeCutter.Size = Vector3.new(10, HOLE_SIZE, HOLE_SIZE)

	-- 3. CSGå®Ÿè¡Œ (ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ– & è¨­å®šå¤‰æ›´)
	local success, result = pcall(function()
		-- CollisionFidelityã‚’Defaultã«å¤‰æ›´ã—ã¦æˆåŠŸç‡ã‚’ä¸Šã’ã‚‹
		return basePart:SubtractAsync({ holeCutter }, Enum.CollisionFidelity.Default)
	end)

	if success and result then
		local unionGoal = result
		unionGoal.Name = "GoalCup"
		unionGoal.Anchored = true
		unionGoal.Parent = model

		-- å…ƒãƒ‘ãƒ¼ãƒ„ç ´æ£„
		basePart:Destroy()
		holeCutter:Destroy()

		-- â˜…è¿½åŠ : è¦–è¦šçš„ãªã‚«ãƒƒãƒ—ã®åº•
		local cupBottom = Instance.new("Part")
		cupBottom.Name = "CupBottom"
		cupBottom.Shape = Enum.PartType.Cylinder
		cupBottom.Size = Vector3.new(0.2, HOLE_SIZE * 0.95, HOLE_SIZE * 0.95)
		cupBottom.Color = Palette.Entity.GoalCup -- æš—ã„è‰²
		cupBottom.Material = Enum.Material.Plastic
		cupBottom.Anchored = true
		cupBottom.CanCollide = true
		-- ã‚´ãƒ¼ãƒ«ã®ä¸­å¤®ä¸‹éƒ¨ã«é…ç½®
		cupBottom.CFrame = unionGoal.CFrame * CFrame.Angles(0, 0, math.rad(90)) * CFrame.new(-GOAL_HEIGHT / 4, 0, 0)
		cupBottom.Parent = model

		-- 4. åˆ¤å®šã‚»ãƒ³ã‚µãƒ¼
		local sensor = Instance.new("Part")
		sensor.Name = "WinSensor"
		sensor.Size = Vector3.new(0.5, HOLE_SIZE * 0.8, HOLE_SIZE * 0.8)
		sensor.Shape = Enum.PartType.Cylinder
		sensor.CFrame = cupBottom.CFrame * CFrame.new(0.5, 0, 0)
		sensor.Transparency = 1
		sensor.CanCollide = false
		sensor.Anchored = true
		sensor.Parent = model

		sensor.Touched:Connect(function(hit)
			if hit.Name == "RedBall" and not isGoalLocked then
				isGoalLocked = true
				print("ğŸ‰ GOAL! Stage Cleared!")
				task.wait(1.5)
				resetGame()
			end
		end)

		-- 5. æ——ã¨ãƒãƒ¼ãƒ«
		local pole = Instance.new("Part")
		pole.Name = "Pole"
		pole.Size = Vector3.new(0.4, 12, 0.4)
		pole.Shape = Enum.PartType.Cylinder
		pole.Color = Palette.Entity.GoalPole
		pole.Anchored = true
		pole.CanCollide = false
		pole.CFrame = unionGoal.CFrame * CFrame.new(0, 5, -4)
		pole.Parent = model

		local flag = Instance.new("Part")
		flag.Name = "Flag"
		flag.Size = Vector3.new(0.2, 3, 4)
		flag.Color = Palette.Entity.GoalFlag
		flag.Anchored = true
		flag.CanCollide = false
		flag.CFrame = pole.CFrame * CFrame.new(0, 4, -2)
		flag.Parent = model

		-- â˜…è¿½åŠ : 4æ–¹å‘ã®ã‚¹ãƒ­ãƒ¼ãƒ—ï¼ˆå‚ï¼‰
		-- ã“ã‚Œã«ã‚ˆã‚ŠBaseplateã‹ã‚‰ã‚¹ãƒ ãƒ¼ã‚ºã«ç™»ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
		local rampLength = 12 -- ç·©ã‚„ã‹ãªå‚ã«ã™ã‚‹
		local directions = {
			{ dir = Vector3.new(0, 0, 1), rot = 0 }, -- æ‰‹å‰
			{ dir = Vector3.new(0, 0, -1), rot = 180 }, -- å¥¥
			{ dir = Vector3.new(-1, 0, 0), rot = -90 }, -- å·¦
			{ dir = Vector3.new(1, 0, 0), rot = 90 }, -- å³
		}

		for _, d in ipairs(directions) do
			local ramp = Instance.new("WedgePart")
			ramp.Name = "GoalRamp"
			ramp.Size = Vector3.new(GOAL_WIDTH, GOAL_HEIGHT, rampLength)
			ramp.Color = Palette.Entity.GoalBase
			ramp.Material = Enum.Material.Grass
			ramp.Anchored = true
			-- ä½ç½®åˆã‚ã›: ã‚´ãƒ¼ãƒ«ä¸­å¿ƒã‹ã‚‰ã€(å¹…åŠåˆ† + å‚é•·ã•åŠåˆ†) ãšã‚‰ã™
			local offset = (GOAL_WIDTH / 2 + rampLength / 2) * d.dir
			-- é«˜ã•åˆã‚ã›: ã‚´ãƒ¼ãƒ«åº•é¢ã¨åŒã˜é«˜ã•ï¼ˆY=0ï¼‰ã«é…ç½®ã™ã‚‹ã¨ã€Wedgeã¯ä¸­å¿ƒåŸºæº–ãªã®ã§èª¿æ•´ãŒå¿…è¦
			-- Wedgeã®é«˜ã•H=6ã€‚ä¸­å¿ƒã¯H/2=3ã€‚GOAL_POSITION.Yã‚‚3ã€‚é«˜ã•ã¯ä¸€è‡´ã€‚
			ramp.CFrame = CFrame.new(GOAL_POSITION + offset) * CFrame.Angles(0, math.rad(d.rot), 0)
			ramp.Parent = model
		end
	else
		warn("Failed to create goal geometry:", result) -- ã‚¨ãƒ©ãƒ¼è©³ç´°ã‚’è¡¨ç¤º
		basePart.Parent = model
	end

	model.Parent = workspace
end

-- â–  ãƒœãƒ¼ãƒ«ç”Ÿæˆ
local function spawnBall()
	if currentBall then
		currentBall:Destroy()
	end

	local ball = Instance.new("Part")
	ball.Name = "RedBall"
	ball.Shape = Enum.PartType.Ball
	ball.Size = Vector3.new(BALL_SIZE, BALL_SIZE, BALL_SIZE)
	ball.Color = Palette.Entity.Ball
	ball.Material = Enum.Material.Plastic
	ball.Position = START_POSITION
	ball.Anchored = true
	ball.CanCollide = true
	ball.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 0.1)
	ball.Parent = workspace

	currentBall = ball
	return ball
end

-- ã‚²ãƒ¼ãƒ é–‹å§‹
local function startGame()
	if currentBall then
		currentBall.Anchored = false
		isGoalLocked = false
		print("Game Started")
	else
		spawnBall()
		currentBall.Anchored = false
		isGoalLocked = false
	end
end

-- ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
local function resetGame()
	isGoalLocked = false
	spawnBall()
	print("Game Reset")
end

-- åˆæœŸåŒ–
spawnGoal()
spawnBall()

-- ã‚¤ãƒ™ãƒ³ãƒˆæ¥ç¶š
GameControlEvent.OnServerEvent:Connect(function(player, action)
	if action == "start" then
		startGame()
	elseif action == "reset" then
		resetGame()
	end
end)

print("GameManager Updated: Goal Ramps and CSG Fix")
